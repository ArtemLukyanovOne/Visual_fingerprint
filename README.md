# Visual_fingerprint


**Visual Fingerprint 64×64** — это приложение на Python, которое строит **графический отпечаток (fingerprint)** по введённой пользователем строке. Такой отпечаток легче сравнивать “глазами”, чем длинные hex-строки: человек быстрее замечает, что картинка “та же самая” или “совсем другая”.

Проект вдохновлён алгоритмом OpenSSH **“The Drunken Bishop”** (randomart), но адаптирован для поля **64×64** с повышенной информативностью и узнаваемостью.

---

## Зачем это нужно

Когда вы проверяете ключи/идентификаторы, hex-fingerprint легко перепутать. Графический отпечаток помогает решить две типовые задачи:

1. Имея перед глазами **два отпечатка**, быстро понять, одинаковые ли они.
2. Имея один отпечаток, быстро понять, **тот же ли он, что и вчера** (узнавание по форме/якорям).

---

## Особенности реализации

### 1) Drunken Bishop (randomart)
Идея: “епископ навеселе” гуляет по дискретной сетке и оставляет след.  
В OpenSSH каждый байт превращается в 4 шага (по 2 бита на шаг), где 2 бита задают направление.

В этом проекте используется тот же принцип: **байты → команды движения → след на поле**.

### 2) Растяжение данных для 64×64 (KDF / SHAKE-256)
Проблема: классический randomart рассчитан на маленькое поле (например, 17×9). На 64×64 исходного хеша недостаточно — получится “тонкая нитка”.

Решение: применяем **SHAKE-256** как детерминированное “растяжение” (KDF):

- входная строка → `SHA-256` (32 байта)
- затем `SHAKE-256` растягивает это до **512/1024/2048 байт**
- каждый байт даёт **4 шага**, поэтому получается ~**2k / 4k / 8k** шагов
- рисунок заполняет 64×64 заметно плотнее и становится узнаваемым

### 3) Детерминированные “якоря” (геометрические маркеры)
Добавляются 4 маркера фиксированной формы (например, кольцо/ромб), вычисляемые из хеша и потока данных.  
Они повышают узнаваемость и снижают шанс спутать отпечатки.

### 4) Автоматическое центрирование по центру масс
Даже если траектория “смещает” рисунок к одному краю, после генерации вычисляется **центр массы** (взвешенный по интенсивности) и выполняется циклический сдвиг так, чтобы рисунок оказался **по центру** холста.

### 5) Логарифмическая обработка яркости
Интенсивность посещений клеток преобразуется в яркость через **log-контраст**, чтобы:
- слабые детали были видимыми,
- фон оставался “гладким”,
- рисунок был читаем без цветовых трюков (важно для дальтонизма).

---

## Требования

- **Python 3.8+**
- **Pillow** (для отрисовки/сохранения PNG)
- **Tkinter** (GUI)

> Tkinter обычно поставляется вместе с Python на Windows/macOS.  
> На некоторых Linux может понадобиться пакет `python3-tk`.

---

## Установка

Рекомендуется виртуальное окружение:

```bash
python -m venv .venv
# Windows:
.venv\Scripts\activate
# macOS/Linux:
source .venv/bin/activate

pip install --upgrade pip
pip install pillow
